package com.mysite{	import flash.display.MovieClip;	import flash.text.TextField;	import flash.text.TextFormat;    import flash.text.TextFieldAutoSize;    import flash.text.TextFormatAlign;    import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.KeyboardEvent;	import flash.ui.Keyboard;		import fl.transitions.easing.*;	import fl.transitions.Tween;	import flash.filters.*;	import fl.motion.AdjustColor;	// Tasklist ////////////////////	/**				1. Поменять цвет у текущего элемента		2. Добавлять эффекты		3. Отформатировать текст		4. geom.Transform 	**/	public class MenuPages extends MovieClip	{		// menu customizer		var txt:Array = ["new game","options","navigation","exit"]				// fx customizer		var fxstime:int = 3;		var defaultSize:int = 1;		var customSize:Number = 1.5;		var menuItem:Array = new Array;		var txtItem:Array = new Array;		var txtlength = txt.length;		var txtField:TextField;		var currentIndex:int = 0;		var myFormat:TextFormat = new TextFormat();		public function MenuPages() 		{			// constructor code			this.addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			/*			всё очевидно			в конструкторе stage всегда будет null, потому что сперва 			объект создаётся, и только потом уже добавляется на сцену			тебе в конструкторе надо не к stage обращаться, а подписаться			на добавление на сцену this.addEventListener(Event.ADDED_TO_STAGE,			onAddedToStage); и в onAddedToStage убрать слушатель и вызвать 			уже это: menuBuilder(); 			stage.addEventListener(KeyboardEvent.KEY_DOWN,navigation);			*/		}		public function onAddedToStage(e:Event):void		{			stage.addEventListener(KeyboardEvent.KEY_DOWN,navigation);			menuBuilder();		}		public function menuBuilder():void		{			trace (txt.length);			for(var i:int = 0; i<txtlength; i++)			{				menuItem[i] = new Circle();				menuItem[i].name = "circle" + i;				menuItem[i].x = stage.stageWidth/2;				menuItem[i].y = 100 + 100 * i;				addChild(menuItem[i]);				txtItem[i] = new TextField;								//defaultTextFormat объекта TextField, чтобы указать				//формат для текста, вводимого пользователем.				//txtItem[i].defaultTextFormat = myFormat;								//trace(txtItem[i].getTextFormat().font);				txtItem[i].text = txt[i];				txtItem[i].setTextFormat(myFormat);				//?				txtItem[0].setTextFormat(myFormat);				myFormat.font = "Helvetica";				//myFormat.underline = true;				myFormat.size = 14;				myFormat.color = 0x009933;				myFormat.bold = true;				//myFormat.italic = true;				myFormat.align = TextFormatAlign.CENTER;				//myFormat.leftMargin = 10;				txtItem[i].width = 120;				txtItem[i].y = -6;				txtItem[i].x = -59;				// TextField customizer								/*				txtItem[i].autoSize = TextFieldAutoSize.LEFT;				//? txtItem[i].type = TextFieldType.DYNAMIC;				txtItem[i].type = "input";				txtItem[i].wordWrap = true; // перенос строк				txtItem[i].textColor = 0xFF0000;				txtItem[i].y;				txtItem[i].x;				txtItem[i].width;				txtItem[i].height;				txtItem[i].border = true;				txtItem[i].borderColor = 0xFF0000;				*/				menuItem[i].addChild(txtItem[i]);				defaultIndex();				// Filters												var outline:GlowFilter=new GlowFilter(0x000000,1.0,2.0,2.0,10);				outline.quality=BitmapFilterQuality.MEDIUM;				txtItem[i].filters=[outline];								var myBlur:BlurFilter = new BlurFilter();				myBlur.quality = 3;				myBlur.blurX = 10;				myBlur.blurY = 10;				txtItem[i].filters=[myBlur];								var myGlow:GlowFilter = new GlowFilter();				myGlow.inner = true;				myGlow.alpha = .5;				myGlow.color = 0x000000;				txtItem[i].filters=[myGlow];				var myBevel:BevelFilter = new BevelFilter();				myBevel.type = BitmapFilterType.FULL;				myBevel.distance = 10;				myBevel.highlightColor = 0xFF0000;				myBevel.shadowColor = 0xFFFF00;				myBevel.blurX = 20;				myBevel.blurY = 20;				txtItem[i].filters = [myBevel];								var myShadow:DropShadowFilter = new DropShadowFilter();				myShadow.distance = 10;				myShadow.color = 0xFF0000;				myShadow.blurX = 10;				myShadow.blurY = 10;				myShadow.quality = 3;				menuItem[i].filters = [myShadow];								var myColor:AdjustColor = new AdjustColor();				var mColourMatrix:ColorMatrixFilter;				var mMatrix:Array;				myColor.hue = -22;				myColor.saturation = 0;				myColor.brightness = 0;				myColor.contrast = 0;								mMatrix = myColor.CalculateFinalFlatArray();				mColourMatrix= new ColorMatrixFilter(mMatrix);				menuItem[i].filters = [mColourMatrix];			}		}		public function navigation(e:KeyboardEvent):void		{			// keyCode			// trace("You pressed key: " + e.keyCode.toString());			if(e.keyCode == 38 && currentIndex > 0)			{				updateCurrent(currentIndex -1)				trace(currentIndex);			} else 			if (e.keyCode == 40 && currentIndex < txtlength-1)			{					trace(txt.length);				updateCurrent(currentIndex +1)				trace(currentIndex);			} else			if(e.keyCode == 13)			{				switch (currentIndex)				{					case 0:							trace("case: "+currentIndex);							eraser();							//var gameInit:Game = new Game();							break;					case 1:							trace("case: "+currentIndex);							eraser();							break;					case 2: 							trace("case: "+currentIndex);							eraser();							break;					case 3:							trace("case: "+currentIndex);							eraser();							break;				}			} else			if(e.keyCode == 27)			{				trace("hey Esc");				menuBuilder();				// установить проверку: рисовать если только				// нет ни одного элемента на сцене.			}		}		public function updateCurrent(newIndex):void		{			nofxs();			currentIndex = newIndex;			fxs();		}		public function fxs():void		{			txtItem[currentIndex].textColor = 0xFF0000;			var scalesBoxX:Tween = new Tween(menuItem[currentIndex],"scaleX", Elastic.easeOut, defaultSize, customSize, fxstime, true);			var scalesBoxY:Tween = new Tween(menuItem[currentIndex],"scaleY", Elastic.easeOut, defaultSize, customSize, fxstime, true);		}		public function nofxs():void		{			txtItem[currentIndex].textColor = 0x009933;			var scalesBoxX:Tween = new Tween(menuItem[currentIndex],"scaleX", Elastic.easeOut, customSize, defaultSize, fxstime, true);			var scalesBoxY:Tween = new Tween(menuItem[currentIndex],"scaleY", Elastic.easeOut, customSize, defaultSize, fxstime, true);		}		public function defaultIndex():void		{			fxs();		}		public function eraser():void		{			for (var i:int = 0; i < txtlength; i++)			{				removeChild(menuItem[i]);				//menuItem[i].removeEventListener(KeyboardEvent.KEY_DOWN,navigation);				// как-то не так удаляю ?				/*ArgumentError: Error #2025: Предоставленный 				DisplayObject должен быть дочерним элементом 				вызывающего объекта.*/			}					}	}	}